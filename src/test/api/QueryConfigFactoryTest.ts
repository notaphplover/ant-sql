import { IEntity } from '@antjs/ant-js/src/model/IEntity';
import { IKeyGenParams } from '@antjs/ant-js/src/model/IKeyGenParams';
import { ITest } from '@antjs/ant-js/src/testapi/api/ITest';
import * as Knex from 'knex';
import { AntSqlManager } from '../../ant';
import { QueryConfigFactory } from '../../api/config/QueryConfigFactory';
import { modelGenerator } from '../model/AntSqlModelGenerator';
import { RedisWrapper } from '../persistence/primary/RedisWrapper';
import { DBTestManager } from '../persistence/secondary/DBTestManager';

const namedModelGenerator = (
  keyGen: IKeyGenParams,
  autoGeneratedId: boolean = false,
) => modelGenerator(keyGen, ['name'], autoGeneratedId ? 'id' : null);

const tableGeneratorColumnId: { name: string, type: 'number'|'string' }
  = { name: 'id', type: 'number' };

const tableGeneratorOtherColumns: { [key: string]: 'string' | 'number'; }
  = { name: 'string' };

type NamedEntityTest = {id: number, name: string} & IEntity;

const MAX_SAFE_TIMEOUT = Math.pow(2, 31) - 1;

export class QueryConfigFactoryTest implements ITest {
  /**
   * Before all promise.
   */
  protected _beforeAllPromise: Promise<any>;
  /**
   * Database connection wrapper.
   */
  protected _dbConnection: Knex;
  /**
   * Database test manager.
   */
  protected _dbTestManager: DBTestManager;
  /**
   * Declare name for the test
   */
  protected _declareName: string;
  /**
   * Redis connection wrapper.
   */
  protected _redisWrapper: RedisWrapper;

  public constructor(
    beforeAllPromise: Promise<any>,
    dbConnection: Knex,
    dbAlias: string,
  ) {
    this._beforeAllPromise = beforeAllPromise;
    this._dbConnection = dbConnection;
    this._dbTestManager = new DBTestManager();
    this._declareName = QueryConfigFactoryTest.name + '/' + dbAlias;
    this._redisWrapper = new RedisWrapper();
  }

  /**
   * Performs all the tests.
   */
  public performTests(): void {
    describe(this._declareName, () => {
      this._itMustBeInitializable();
      this._itMustBuildAnMQueryByFieldThatReturnsAnEmptyArrayIfAnEmptyParamsArrayIsProvided();
      this._itMustBuildAnMQueryByUniqueFieldThatReturnsAnEmptyArrayIfAnEmptyParamsArrayIsProvided();
      this._itMustBuildAQueryAllThatDoesNotNeedParameters();
      this._itMustBuildAQueryByFieldThatNeedsParameters();
      this._itMustBuildAQueryByFieldsThatNeedsParameters();
      this._itMustBuildAQueryByUniqueFieldThatNeedsParameters();
      this._itMustBuildAQueryByUniqueFieldsThatNeedsParameters();
      this._itMustBuildAQueryByUniqueFieldThatReturnsNullIfNoEntityIsFound();
      this._itMustBuildAQueryByUniqueFieldsThatReturnsNullIfNoEntityIsFound();
      this._itMustBuildAValidQueryAllBuildConfig();
      this._itMustBuildAValidQueryAllWithParameters();
      this._itMustBuildAValidQueryByFieldConfig();
      this._itMustBuildAValidQueryByFieldsConfig();
      this._itMustBuildAValidQueryByUniqueFieldConfig();
      this._itMustBuildAValidQueryByUniqueFieldsConfig();
      this._itMustMQueryWithRepeatedQueries();
    });
  }

  private _itMustBeInitializable(): void {
    const itsName = 'It must be initializable';
    const prefix = this._declareName + '/' + itsName + '/';
    it(itsName, async (done) => {
      const model = namedModelGenerator({ prefix: prefix });
      expect(() => {
        // tslint:disable-next-line:no-unused-expression
        new QueryConfigFactory(this._dbConnection, model);
      });
      done();
    }, MAX_SAFE_TIMEOUT);
  }

  private _itMustBuildAnMQueryByFieldThatReturnsAnEmptyArrayIfAnEmptyParamsArrayIsProvided(): void {
    const itsName = 'It must build an mquery by field that returns an empty array if an empty params array is provided';
    const prefix = this._declareName + '/' + itsName + '/';
    it(itsName, async (done) => {
      await this._beforeAllPromise;

      const model = namedModelGenerator({ prefix: prefix });
      await this._dbTestManager.createTable(
        this._dbConnection,
        model.tableName,
        tableGeneratorColumnId,
        tableGeneratorOtherColumns,
      );

      const factory = new QueryConfigFactory<NamedEntityTest>(this._dbConnection, model);
      const queryConfig = factory.byField(model.getColumn('name'));

      expect(await queryConfig.mQuery(new Array())).toEqual(new Array());
      done();
    }, MAX_SAFE_TIMEOUT);
  }

  private _itMustBuildAnMQueryByUniqueFieldThatReturnsAnEmptyArrayIfAnEmptyParamsArrayIsProvided(): void {
    const itsName =
      'It must build an mquery by unique field that returns an empty array if an empty params array is provided';
    const prefix = this._declareName + '/' + itsName + '/';
    it(itsName, async (done) => {
      await this._beforeAllPromise;

      const model = namedModelGenerator({ prefix: prefix });
      await this._dbTestManager.createTable(
        this._dbConnection,
        model.tableName,
        tableGeneratorColumnId,
        tableGeneratorOtherColumns,
      );

      const factory = new QueryConfigFactory<NamedEntityTest>(this._dbConnection, model);
      const queryConfig = factory.byUniqueField(model.getColumn('name'));

      expect(await queryConfig.mQuery(new Array())).toEqual(new Array());
      done();
    }, MAX_SAFE_TIMEOUT);
  }

  private _itMustBuildAQueryAllThatDoesNotNeedParameters(): void {
    const itsName = 'It must build an all query that does not need parameters';
    const prefix = this._declareName + '/' + itsName + '/';

    it(itsName, async (done) => {
      await this._beforeAllPromise;

      const model = namedModelGenerator({ prefix: prefix });
      await this._dbTestManager.createTable(
        this._dbConnection,
        model.tableName,
        tableGeneratorColumnId,
        tableGeneratorOtherColumns,
      );

      const factory = new QueryConfigFactory<NamedEntityTest>(this._dbConnection, model);
      const queryConfig = factory.all();

      expect(() => queryConfig.query(null)).not.toThrowError();
      expect(() => queryConfig.query({})).not.toThrowError();

      done();
    }, MAX_SAFE_TIMEOUT);
  }

  private _itMustBuildAQueryByFieldThatNeedsParameters(): void {
    const itsName = 'It must build a query by field that needs parameters';
    const prefix = this._declareName + '/' + itsName + '/';
    it(itsName, async (done) => {
      await this._beforeAllPromise;

      const model = namedModelGenerator({ prefix: prefix });
      await this._dbTestManager.createTable(
        this._dbConnection,
        model.tableName,
        tableGeneratorColumnId,
        tableGeneratorOtherColumns,
      );

      const factory = new QueryConfigFactory<NamedEntityTest>(this._dbConnection, model);
      const queryConfig = factory.byField(model.getColumn('name'));

      expect(() => queryConfig.query(null)).toThrowError();
      expect(() => queryConfig.query({})).toThrowError();
      expect(() => queryConfig.mQuery(null)).toThrowError();

      done();
    }, MAX_SAFE_TIMEOUT);
  }

  private _itMustBuildAQueryByFieldsThatNeedsParameters(): void {
    const itsName = 'It must build a query by fields that needs parameters';
    const prefix = this._declareName + '/' + itsName + '/';
    it(itsName, async (done) => {
      await this._beforeAllPromise;

      const model = namedModelGenerator({ prefix: prefix });
      await this._dbTestManager.createTable(
        this._dbConnection,
        model.tableName,
        tableGeneratorColumnId,
        tableGeneratorOtherColumns,
      );

      const factory = new QueryConfigFactory<NamedEntityTest>(this._dbConnection, model);
      const queryConfig = factory.byFields([model.getColumn('name')]);

      expect(() => queryConfig.query(null)).toThrowError();
      expectAsync(queryConfig.query({})).toBeRejected();
      expect(() => queryConfig.mQuery(null)).toThrowError();

      done();
    }, MAX_SAFE_TIMEOUT);
  }

  private _itMustBuildAQueryByUniqueFieldThatNeedsParameters(): void {
    const itsName = 'It must build a query by unique field that needs parameters';
    const prefix = this._declareName + '/' + itsName + '/';
    it(itsName, async (done) => {
      await this._beforeAllPromise;

      const model = namedModelGenerator({ prefix: prefix });
      await this._dbTestManager.createTable(
        this._dbConnection,
        model.tableName,
        tableGeneratorColumnId,
        tableGeneratorOtherColumns,
      );

      const factory = new QueryConfigFactory<NamedEntityTest>(this._dbConnection, model);
      const queryConfig = factory.byUniqueField(model.getColumn('name'));

      expect(() => queryConfig.query(null)).toThrowError();
      expect(() => queryConfig.query({})).toThrowError();
      expect(() => queryConfig.mQuery(null)).toThrowError();

      done();
    }, MAX_SAFE_TIMEOUT);
  }

  private _itMustBuildAQueryByUniqueFieldsThatNeedsParameters(): void {
    const itsName = 'It must build a query by unique fields that needs parameters';
    const prefix = this._declareName + '/' + itsName + '/';
    it(itsName, async (done) => {
      await this._beforeAllPromise;

      const model = namedModelGenerator({ prefix: prefix });
      await this._dbTestManager.createTable(
        this._dbConnection,
        model.tableName,
        tableGeneratorColumnId,
        tableGeneratorOtherColumns,
      );

      const factory = new QueryConfigFactory<NamedEntityTest>(this._dbConnection, model);
      const queryConfig = factory.byUniqueFields([model.getColumn('name')]);

      expect(() => queryConfig.query(null)).toThrowError();
      expectAsync(queryConfig.query({})).toBeRejected();
      expect(() => queryConfig.mQuery(null)).toThrowError();

      done();
    }, MAX_SAFE_TIMEOUT);
  }

  private _itMustBuildAQueryByUniqueFieldThatReturnsNullIfNoEntityIsFound(): void {
    const itsName = 'It must build a query by unique field that returns null if no entity is found';
    const prefix = this._declareName + '/' + itsName + '/';
    it(itsName, async (done) => {
      await this._beforeAllPromise;

      const model = namedModelGenerator({ prefix: prefix });
      await this._dbTestManager.createTable(
        this._dbConnection,
        model.tableName,
        tableGeneratorColumnId,
        tableGeneratorOtherColumns,
      );

      const factory = new QueryConfigFactory<NamedEntityTest>(this._dbConnection, model);
      const queryConfig = factory.byUniqueField(model.getColumn('name'));

      const entityFound = await queryConfig.query({ name: 'name-1' });

      expect(entityFound).toBeNull();
      done();
    }, MAX_SAFE_TIMEOUT);
  }

  private _itMustBuildAQueryByUniqueFieldsThatReturnsNullIfNoEntityIsFound(): void {
    const itsName = 'It must build a query by unique fields that returns null if no entity is found';
    const prefix = this._declareName + '/' + itsName + '/';
    it(itsName, async (done) => {
      await this._beforeAllPromise;

      const model = namedModelGenerator({ prefix: prefix });
      await this._dbTestManager.createTable(
        this._dbConnection,
        model.tableName,
        tableGeneratorColumnId,
        tableGeneratorOtherColumns,
      );

      const factory = new QueryConfigFactory<NamedEntityTest>(this._dbConnection, model);
      const queryConfig = factory.byUniqueFields([model.getColumn('name')]);

      const entityFound = await queryConfig.query({ name: 'name-1' });

      expect(entityFound).toBeNull();
      done();
    }, MAX_SAFE_TIMEOUT);
  }

  private _itMustBuildAValidQueryAllBuildConfig(): void {
    const itsName = 'It must build a valid all query config';
    const prefix = this._declareName + '/' + itsName + '/';

    it(itsName, async (done) => {
      await this._beforeAllPromise;

      const model = namedModelGenerator({ prefix: prefix });
      await this._dbTestManager.createTable(
        this._dbConnection,
        model.tableName,
        tableGeneratorColumnId,
        tableGeneratorOtherColumns,
      );

      const antSqlManager = new AntSqlManager();
      const factory = new QueryConfigFactory<NamedEntityTest>(this._dbConnection, model);
      const modelManager = antSqlManager
        .get(model)
        .config({
          knex: this._dbConnection,
          redis: this._redisWrapper.redis,
        });
      const query = modelManager.query(factory.all());

      const player1 = { id: 1, name: 'name-1' };
      const player2 = { id: 2, name: 'name-1' };
      const player3 = { id: 3, name: 'name-2' };
      const player4 = { id: 4, name: 'name-3' };

      await modelManager.mInsert([
        player1,
        player2,
        player3,
        player4,
      ]);

      const playersQueryResult = await query.get({});
      const playersMQueryResult = await query.mGet([{}]);

      expect(playersQueryResult).toContain(player1);
      expect(playersQueryResult).toContain(player2);
      expect(playersQueryResult).toContain(player3);
      expect(playersQueryResult).toContain(player4);

      expect(playersMQueryResult).toContain(player1);
      expect(playersMQueryResult).toContain(player2);
      expect(playersMQueryResult).toContain(player3);
      expect(playersMQueryResult).toContain(player4);

      done();
    }, MAX_SAFE_TIMEOUT);
  }

  private _itMustBuildAValidQueryAllWithParameters(): void {
    const itsName = 'It must build a valid all query config with parameters';
    const prefix = this._declareName + '/' + itsName + '/';

    it(itsName, async (done) => {
      await this._beforeAllPromise;

      const model = namedModelGenerator({ prefix: prefix });
      await this._dbTestManager.createTable(
        this._dbConnection,
        model.tableName,
        tableGeneratorColumnId,
        tableGeneratorOtherColumns,
      );

      const antSqlManager = new AntSqlManager();
      const factory = new QueryConfigFactory<NamedEntityTest>(this._dbConnection, model);
      const modelManager = antSqlManager
        .get(model)
        .config({
          knex: this._dbConnection,
          redis: this._redisWrapper.redis,
        });

      const keyGen = () => prefix + 'k-k-key';
      const reverseKey = prefix + 'reverse-key';

      const query = modelManager.query(factory.all({
        entityKeyGen: keyGen,
        queryKeyGen: keyGen,
        reverseHashKey: reverseKey,
      }));

      const player1 = { id: 1, name: 'name-1' };
      const player2 = { id: 2, name: 'name-1' };
      const player3 = { id: 3, name: 'name-2' };
      const player4 = { id: 4, name: 'name-3' };

      await modelManager.mInsert([
        player1,
        player2,
        player3,
        player4,
      ]);

      await query.get({});

      const resultKeyExist = await this._redisWrapper.redis.exists(keyGen());
      const reverseKeyExists = await this._redisWrapper.redis.exists(reverseKey);
      const expectedResult = 1; // Exists (https://redis.io/commands/exists)

      expect(resultKeyExist).toBe(expectedResult);
      expect(reverseKeyExists).toBe(expectedResult);

      done();
    }, MAX_SAFE_TIMEOUT);
  }

  private _itMustBuildAValidQueryByFieldConfig(): void {
    const itsName = 'It must build a valid query by field config';
    const prefix = this._declareName + '/' + itsName + '/';
    it(itsName, async (done) => {
      await this._beforeAllPromise;

      const model = namedModelGenerator({ prefix: prefix });
      await this._dbTestManager.createTable(
        this._dbConnection,
        model.tableName,
        tableGeneratorColumnId,
        tableGeneratorOtherColumns,
      );

      const antSqlManager = new AntSqlManager();
      const factory = new QueryConfigFactory<NamedEntityTest>(this._dbConnection, model);
      const modelManager = antSqlManager
        .get(model)
        .config({
          knex: this._dbConnection,
          redis: this._redisWrapper.redis,
        });
      const query = modelManager.query(factory.byField(model.getColumn('name')));

      const player1 = { id: 1, name: 'name-1' };
      const player2 = { id: 2, name: 'name-1' };
      const player3 = { id: 3, name: 'name-2' };
      const player4 = { id: 4, name: 'name-3' };

      await modelManager.mInsert([
        player1,
        player2,
        player3,
        player4,
      ]);

      const playersByName = await query.get({name: 'name-1'});
      const playersByNames = await query.mGet([
        {name: 'name-1'},
        {name: 'name-2'},
      ]);

      expect(playersByName).toContain(player1);
      expect(playersByName).toContain(player2);
      expect(playersByName).not.toContain(player3);
      expect(playersByName).not.toContain(player4);

      expect(playersByNames).toContain(player1);
      expect(playersByNames).toContain(player2);
      expect(playersByNames).toContain(player3);
      expect(playersByNames).not.toContain(player4);

      done();
    }, MAX_SAFE_TIMEOUT);
  }

  private _itMustBuildAValidQueryByFieldsConfig(): void {
    const itsName = 'It must build a valid query by fields config';
    const prefix = this._declareName + '/' + itsName + '/';
    it(itsName, async (done) => {
      await this._beforeAllPromise;

      const model = namedModelGenerator({ prefix: prefix });
      await this._dbTestManager.createTable(
        this._dbConnection,
        model.tableName,
        tableGeneratorColumnId,
        tableGeneratorOtherColumns,
      );

      const antSqlManager = new AntSqlManager();
      const factory = new QueryConfigFactory<NamedEntityTest>(this._dbConnection, model);
      const modelManager = antSqlManager
        .get(model)
        .config({
          knex: this._dbConnection,
          redis: this._redisWrapper.redis,
        });
      const query = modelManager.query(factory.byFields([model.getColumn('name')]));

      const player1 = { id: 1, name: 'name-1' };
      const player2 = { id: 2, name: 'name-1' };
      const player3 = { id: 3, name: 'name-2' };
      const player4 = { id: 4, name: 'name-3' };

      await modelManager.mInsert([
        player1,
        player2,
        player3,
        player4,
      ]);

      const playersByName = await query.get({name: 'name-1'});
      const playersByNames = await query.mGet([
        {name: 'name-1'},
        {name: 'name-2'},
      ]);

      expect(playersByName).toContain(player1);
      expect(playersByName).toContain(player2);
      expect(playersByName).not.toContain(player3);
      expect(playersByName).not.toContain(player4);

      expect(playersByNames).toContain(player1);
      expect(playersByNames).toContain(player2);
      expect(playersByNames).toContain(player3);
      expect(playersByNames).not.toContain(player4);

      done();
    }, MAX_SAFE_TIMEOUT);
  }

  private _itMustBuildAValidQueryByUniqueFieldConfig(): void {
    const itsName = 'It must build a valid query by unique field config';
    const prefix = this._declareName + '/' + itsName + '/';
    it(itsName, async (done) => {
      await this._beforeAllPromise;

      const model = namedModelGenerator({ prefix: prefix });
      await this._dbTestManager.createTable(
        this._dbConnection,
        model.tableName,
        tableGeneratorColumnId,
        tableGeneratorOtherColumns,
      );

      const antSqlManager = new AntSqlManager();
      const factory = new QueryConfigFactory<NamedEntityTest>(this._dbConnection, model);
      const modelManager = antSqlManager
        .get<NamedEntityTest>(model)
        .config({
          knex: this._dbConnection,
          redis: this._redisWrapper.redis,
        });

      const player1 = { id: 1, name: 'name-1' };
      const player2 = { id: 2, name: 'name-2' };
      const player3 = { id: 3, name: 'name-3' };
      const player4 = { id: 4, name: 'name-4' };
      await modelManager.mInsert([
        player1,
        player2,
        player3,
        player4,
      ]);

      const query = modelManager.query(factory.byUniqueField(model.getColumn('name')));

      const playerByName = await query.get({name: player1.name});
      const playersByNames = await query.mGet([
        {name: player1.name},
        {name: player2.name},
      ]);

      expect(playerByName).toEqual(player1);

      expect(playersByNames).toContain(player1);
      expect(playersByNames).toContain(player2);
      expect(playersByNames).not.toContain(player3);
      expect(playersByNames).not.toContain(player4);

      done();
    }, MAX_SAFE_TIMEOUT);
  }

  private _itMustBuildAValidQueryByUniqueFieldsConfig(): void {
    const itsName = 'It must build a valid query by unique fields config';
    const prefix = this._declareName + '/' + itsName + '/';
    it(itsName, async (done) => {
      await this._beforeAllPromise;

      const model = namedModelGenerator({ prefix: prefix });
      await this._dbTestManager.createTable(
        this._dbConnection,
        model.tableName,
        tableGeneratorColumnId,
        tableGeneratorOtherColumns,
      );

      const antSqlManager = new AntSqlManager();
      const factory = new QueryConfigFactory<NamedEntityTest>(this._dbConnection, model);
      const modelManager = antSqlManager
        .get<NamedEntityTest>(model)
        .config({
          knex: this._dbConnection,
          redis: this._redisWrapper.redis,
        });

      const player1 = { id: 1, name: 'name-1' };
      const player2 = { id: 2, name: 'name-2' };
      const player3 = { id: 3, name: 'name-3' };
      const player4 = { id: 4, name: 'name-4' };
      await modelManager.mInsert([
        player1,
        player2,
        player3,
        player4,
      ]);

      const query = modelManager.query(factory.byUniqueFields([model.getColumn('name')]));

      const playerByName = await query.get({name: player1.name});
      const playersByNames = await query.mGet([
        {name: player1.name},
        {name: player2.name},
      ]);

      expect(playerByName).toEqual(player1);

      expect(playersByNames).toContain(player1);
      expect(playersByNames).toContain(player2);
      expect(playersByNames).not.toContain(player3);
      expect(playersByNames).not.toContain(player4);

      done();
    }, MAX_SAFE_TIMEOUT);
  }

  private _itMustMQueryWithRepeatedQueries(): void {
    const itsName = 'It must perform an mquery with repeated queries';
    const prefix = this._declareName + '/' + itsName + '/';
    it(itsName, async (done) => {
      await this._beforeAllPromise;

      const model = namedModelGenerator({ prefix: prefix });
      await this._dbTestManager.createTable(
        this._dbConnection,
        model.tableName,
        tableGeneratorColumnId,
        tableGeneratorOtherColumns,
      );

      const antSqlManager = new AntSqlManager();
      const factory = new QueryConfigFactory<NamedEntityTest>(this._dbConnection, model);
      const modelManager = antSqlManager
        .get<NamedEntityTest>(model)
        .config({
          knex: this._dbConnection,
          redis: this._redisWrapper.redis,
        });
      const query = modelManager.query(factory.byField(model.getColumn('name')));

      const player1 = { id: 1, name: 'name-1' };
      const player2 = { id: 2, name: 'name-1' };
      const player3 = { id: 3, name: 'name-2' };
      const player4 = { id: 4, name: 'name-3' };

      await modelManager.mInsert([
        player1,
        player2,
        player3,
        player4,
      ]);

      const playersByNames = await query.mGet([
        {name: 'name-1'},
        {name: 'name-1'},
      ]);

      expect(playersByNames).toContain(player1);
      expect(playersByNames).toContain(player2);
      expect(playersByNames).not.toContain(player3);
      expect(playersByNames).not.toContain(player4);

      done();
    }, MAX_SAFE_TIMEOUT);
  }
}
