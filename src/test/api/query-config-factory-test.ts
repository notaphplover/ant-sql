import * as Knex from 'knex';
import { Entity, KeyGenParams } from '@antjs/ant-js';
import { modelGenerator, tableNameGenerator } from '../model/ant-sql-model-generator';
import { AntSqlManager } from '../../api/ant-sql-manager';
import { AntSqlModel } from '../../model/ant-sql-model';
import { AutoGeneratedStrategyMode } from '../../model/auto-generation-strategy-mode';
import { DBTestManager } from '../persistence/secondary/db-test-manager';
import { QueryConfigFactory } from '../../api/config/query-config-factory';
import { RedisWrapper } from '../persistence/primary/redis-wrapper';
import { SqlModel } from '../../model/sql-model';
import { SqlType } from '../../model/sql-type';
import { Test } from '@antjs/ant-js/build/testapi/api/test';

const namedModelGenerator = (keyGen: KeyGenParams, autoGeneratedId = false): SqlModel<NamedEntityTest> =>
  modelGenerator<NamedEntityTest>(keyGen, ['name'], autoGeneratedId ? 'id' : null);

const tableGeneratorColumnId: { name: string; type: 'number' | 'string' } = { name: 'id', type: 'number' };

const tableGeneratorOtherColumns: { [key: string]: 'string' | 'number' } = { name: 'string' };

type AmountEntity = { amount: number; id: number } & Entity;

type NamedEntityTest = { id: number; name: string } & Entity;

const MAX_SAFE_TIMEOUT = Math.pow(2, 31) - 1;

export class QueryConfigFactoryTest implements Test {
  /**
   * Before all promise.
   */
  protected _beforeAllPromise: Promise<any>;
  /**
   * Database connection wrapper.
   */
  protected _dbConnection: Knex;
  /**
   * Database test manager.
   */
  protected _dbTestManager: DBTestManager;
  /**
   * Declare name for the test
   */
  protected _declareName: string;
  /**
   * Redis connection wrapper.
   */
  protected _redisWrapper: RedisWrapper;

  public constructor(beforeAllPromise: Promise<any>, dbConnection: Knex, dbAlias: string) {
    this._beforeAllPromise = beforeAllPromise;
    this._dbConnection = dbConnection;
    this._dbTestManager = new DBTestManager();
    this._declareName = QueryConfigFactoryTest.name + '/' + dbAlias;
    this._redisWrapper = new RedisWrapper();
  }

  /**
   * Performs all the tests.
   */
  public performTests(): void {
    describe(this._declareName, () => {
      this._itMustBeInitializable();
      this._itMustBuildAnMQueryByFieldThatReturnsAnEmptyArrayIfAnEmptyParamsArrayIsProvided();
      this._itMustBuildAnMQueryByUniqueFieldThatReturnsAnEmptyArrayIfAnEmptyParamsArrayIsProvided();
      this._itMustBuildAQueryAllThatDoesNotNeedParameters();
      this._itMustBuildAQueryByFieldThatNeedsParameters();
      this._itMustBuildAQueryByFieldsThatNeedsParameters();
      this._itMustBuildAQueryByNumericRangeThatNeedsANumericColumn();
      this._itMustBuildAQueryByNumericRangeThatNeedsParameters();
      this._itMustBuildAQueryByUniqueFieldThatNeedsParameters();
      this._itMustBuildAQueryByUniqueFieldsThatNeedsParameters();
      this._itMustBuildAQueryByUniqueFieldThatReturnsNullIfNoEntityIsFound();
      this._itMustBuildAQueryByUniqueFieldsThatReturnsNullIfNoEntityIsFound();
      this._itMustBuildAValidQueryAllBuildConfig();
      this._itMustBuildAValidQueryAllWithParameters();
      this._itMustBuildAValidQueryByFieldConfig();
      this._itMustBuildAValidQueryByFieldsConfig();
      this._itMustBuildAValidQueryByNumericRangeConfig();
      this._itMustBuildAValidQueryByNumericRangeConfigThatSyncsEntities();
      this._itMustBuildAValidQueryByUniqueFieldConfig();
      this._itMustBuildAValidQueryByUniqueFieldsConfig();
      this._itMustMQueryWithRepeatedQueries();
    });
  }

  private _itMustBeInitializable(): void {
    const itsName = 'It must be initializable';
    const prefix = this._declareName + '/' + itsName + '/';
    it(
      itsName,
      async (done) => {
        const model = namedModelGenerator({ prefix });
        expect(() => {
          new QueryConfigFactory(this._dbConnection, model);
        });
        done();
      },
      MAX_SAFE_TIMEOUT,
    );
  }

  private _itMustBuildAnMQueryByFieldThatReturnsAnEmptyArrayIfAnEmptyParamsArrayIsProvided(): void {
    const itsName = 'It must build an mquery by field that returns an empty array if an empty params array is provided';
    const prefix = this._declareName + '/' + itsName + '/';
    it(
      itsName,
      async (done) => {
        await this._beforeAllPromise;

        const model = namedModelGenerator({ prefix });
        await this._dbTestManager.createTable(
          this._dbConnection,
          model.tableName,
          tableGeneratorColumnId,
          tableGeneratorOtherColumns,
        );

        const factory = new QueryConfigFactory<NamedEntityTest>(this._dbConnection, model);
        const queryConfig = factory.byField(model.columnByAlias('name'));

        expect(await queryConfig.mQuery(new Array())).toEqual(new Array());
        done();
      },
      MAX_SAFE_TIMEOUT,
    );
  }

  private _itMustBuildAnMQueryByUniqueFieldThatReturnsAnEmptyArrayIfAnEmptyParamsArrayIsProvided(): void {
    const itsName =
      'It must build an mquery by unique field that returns an empty array if an empty params array is provided';
    const prefix = this._declareName + '/' + itsName + '/';
    it(
      itsName,
      async (done) => {
        await this._beforeAllPromise;

        const model = namedModelGenerator({ prefix });
        await this._dbTestManager.createTable(
          this._dbConnection,
          model.tableName,
          tableGeneratorColumnId,
          tableGeneratorOtherColumns,
        );

        const factory = new QueryConfigFactory<NamedEntityTest>(this._dbConnection, model);
        const queryConfig = factory.byUniqueField(model.columnByAlias('name'));

        expect(await queryConfig.mQuery(new Array())).toEqual(new Array());
        done();
      },
      MAX_SAFE_TIMEOUT,
    );
  }

  private _itMustBuildAQueryAllThatDoesNotNeedParameters(): void {
    const itsName = 'It must build an all query that does not need parameters';
    const prefix = this._declareName + '/' + itsName + '/';

    it(
      itsName,
      async (done) => {
        await this._beforeAllPromise;

        const model = namedModelGenerator({ prefix });
        await this._dbTestManager.createTable(
          this._dbConnection,
          model.tableName,
          tableGeneratorColumnId,
          tableGeneratorOtherColumns,
        );

        const factory = new QueryConfigFactory<NamedEntityTest>(this._dbConnection, model);
        const queryConfig = factory.all();

        expect(() => queryConfig.query(null)).not.toThrowError();
        expect(() => queryConfig.query({})).not.toThrowError();

        done();
      },
      MAX_SAFE_TIMEOUT,
    );
  }

  private _itMustBuildAQueryByFieldThatNeedsParameters(): void {
    const itsName = 'It must build a query by field that needs parameters';
    const prefix = this._declareName + '/' + itsName + '/';
    it(
      itsName,
      async (done) => {
        await this._beforeAllPromise;

        const model = namedModelGenerator({ prefix });
        await this._dbTestManager.createTable(
          this._dbConnection,
          model.tableName,
          tableGeneratorColumnId,
          tableGeneratorOtherColumns,
        );

        const factory = new QueryConfigFactory<NamedEntityTest>(this._dbConnection, model);
        const queryConfig = factory.byField(model.columnByAlias('name'));

        expect(() => queryConfig.query(null)).toThrowError();
        expect(() => queryConfig.query({})).toThrowError();
        expect(() => queryConfig.mQuery(null)).toThrowError();

        done();
      },
      MAX_SAFE_TIMEOUT,
    );
  }

  private _itMustBuildAQueryByFieldsThatNeedsParameters(): void {
    const itsName = 'It must build a query by fields that needs parameters';
    const prefix = this._declareName + '/' + itsName + '/';
    it(
      itsName,
      async (done) => {
        await this._beforeAllPromise;

        const model = namedModelGenerator({ prefix });
        await this._dbTestManager.createTable(
          this._dbConnection,
          model.tableName,
          tableGeneratorColumnId,
          tableGeneratorOtherColumns,
        );

        const factory = new QueryConfigFactory<NamedEntityTest>(this._dbConnection, model);
        const queryConfig = factory.byFields([model.columnByAlias('name')]);

        expect(() => queryConfig.query(null)).toThrowError();
        expectAsync(queryConfig.query({})).toBeRejected();
        expect(() => queryConfig.mQuery(null)).toThrowError();

        done();
      },
      MAX_SAFE_TIMEOUT,
    );
  }

  private _itMustBuildAQueryByNumericRangeThatNeedsANumericColumn(): void {
    const itsName = 'It must build a query by numeric range that needs a numeric column';
    const prefix = this._declareName + '/' + itsName + '/';
    it(
      itsName,
      async (done) => {
        await this._beforeAllPromise;

        const model = new AntSqlModel<AmountEntity>(
          'id',
          { prefix },
          [
            {
              autoGenerationStrategy: AutoGeneratedStrategyMode.AutoIncrement,
              entityAlias: 'id',
              sqlName: 'id',
              type: SqlType.Integer,
            },
            {
              entityAlias: 'amount',
              sqlName: 'amount',
              type: SqlType.String,
            },
          ],
          tableNameGenerator(prefix),
        );
        await this._dbTestManager.createTable(this._dbConnection, model.tableName, tableGeneratorColumnId, {
          amount: 'number',
        });

        const factory = new QueryConfigFactory<AmountEntity>(this._dbConnection, model);
        expect(() =>
          factory.byNumericRange(model.columnByAlias('amount'), { blockSize: 100, minValueField: 'offSet' }),
        ).toThrowError();

        done();
      },
      MAX_SAFE_TIMEOUT,
    );
  }

  private _itMustBuildAQueryByNumericRangeThatNeedsParameters(): void {
    const itsName = 'It must build a query by numeric range that needs parameters';
    const prefix = this._declareName + '/' + itsName + '/';
    it(
      itsName,
      async (done) => {
        await this._beforeAllPromise;

        const model = new AntSqlModel<AmountEntity>(
          'id',
          { prefix },
          [
            {
              autoGenerationStrategy: AutoGeneratedStrategyMode.AutoIncrement,
              entityAlias: 'id',
              sqlName: 'id',
              type: SqlType.Integer,
            },
            {
              entityAlias: 'amount',
              sqlName: 'amount',
              type: SqlType.Integer,
            },
          ],
          tableNameGenerator(prefix),
        );
        await this._dbTestManager.createTable(this._dbConnection, model.tableName, tableGeneratorColumnId, {
          amount: 'number',
        });

        const factory = new QueryConfigFactory<AmountEntity>(this._dbConnection, model);
        const queryConfig = factory.byNumericRange(model.columnByAlias('amount'), {
          blockSize: 100,
          minValueField: 'offSet',
        });

        expect(() => queryConfig.query(null)).toThrowError();
        expect(() => queryConfig.query({})).toThrowError();
        expect(() => queryConfig.mQuery(null)).toThrowError();

        done();
      },
      MAX_SAFE_TIMEOUT,
    );
  }

  private _itMustBuildAQueryByUniqueFieldThatNeedsParameters(): void {
    const itsName = 'It must build a query by unique field that needs parameters';
    const prefix = this._declareName + '/' + itsName + '/';
    it(
      itsName,
      async (done) => {
        await this._beforeAllPromise;

        const model = namedModelGenerator({ prefix });
        await this._dbTestManager.createTable(
          this._dbConnection,
          model.tableName,
          tableGeneratorColumnId,
          tableGeneratorOtherColumns,
        );

        const factory = new QueryConfigFactory<NamedEntityTest>(this._dbConnection, model);
        const queryConfig = factory.byUniqueField(model.columnByAlias('name'));

        expect(() => queryConfig.query(null)).toThrowError();
        expect(() => queryConfig.query({})).toThrowError();
        expect(() => queryConfig.mQuery(null)).toThrowError();

        done();
      },
      MAX_SAFE_TIMEOUT,
    );
  }

  private _itMustBuildAQueryByUniqueFieldsThatNeedsParameters(): void {
    const itsName = 'It must build a query by unique fields that needs parameters';
    const prefix = this._declareName + '/' + itsName + '/';
    it(
      itsName,
      async (done) => {
        await this._beforeAllPromise;

        const model = namedModelGenerator({ prefix });
        await this._dbTestManager.createTable(
          this._dbConnection,
          model.tableName,
          tableGeneratorColumnId,
          tableGeneratorOtherColumns,
        );

        const factory = new QueryConfigFactory<NamedEntityTest>(this._dbConnection, model);
        const queryConfig = factory.byUniqueFields([model.columnByAlias('name')]);

        expect(() => queryConfig.query(null)).toThrowError();
        expectAsync(queryConfig.query({})).toBeRejected();
        expect(() => queryConfig.mQuery(null)).toThrowError();

        done();
      },
      MAX_SAFE_TIMEOUT,
    );
  }

  private _itMustBuildAQueryByUniqueFieldThatReturnsNullIfNoEntityIsFound(): void {
    const itsName = 'It must build a query by unique field that returns null if no entity is found';
    const prefix = this._declareName + '/' + itsName + '/';
    it(
      itsName,
      async (done) => {
        await this._beforeAllPromise;

        const model = namedModelGenerator({ prefix });
        await this._dbTestManager.createTable(
          this._dbConnection,
          model.tableName,
          tableGeneratorColumnId,
          tableGeneratorOtherColumns,
        );

        const factory = new QueryConfigFactory<NamedEntityTest>(this._dbConnection, model);
        const queryConfig = factory.byUniqueField(model.columnByAlias('name'));

        const entityFound = await queryConfig.query({ name: 'name-1' });

        expect(entityFound).toBeNull();
        done();
      },
      MAX_SAFE_TIMEOUT,
    );
  }

  private _itMustBuildAQueryByUniqueFieldsThatReturnsNullIfNoEntityIsFound(): void {
    const itsName = 'It must build a query by unique fields that returns null if no entity is found';
    const prefix = this._declareName + '/' + itsName + '/';
    it(
      itsName,
      async (done) => {
        await this._beforeAllPromise;

        const model = namedModelGenerator({ prefix });
        await this._dbTestManager.createTable(
          this._dbConnection,
          model.tableName,
          tableGeneratorColumnId,
          tableGeneratorOtherColumns,
        );

        const factory = new QueryConfigFactory<NamedEntityTest>(this._dbConnection, model);
        const queryConfig = factory.byUniqueFields([model.columnByAlias('name')]);

        const entityFound = await queryConfig.query({ name: 'name-1' });

        expect(entityFound).toBeNull();
        done();
      },
      MAX_SAFE_TIMEOUT,
    );
  }

  private _itMustBuildAValidQueryAllBuildConfig(): void {
    const itsName = 'It must build a valid all query config';
    const prefix = this._declareName + '/' + itsName + '/';

    it(
      itsName,
      async (done) => {
        await this._beforeAllPromise;

        const model = namedModelGenerator({ prefix });
        await this._dbTestManager.createTable(
          this._dbConnection,
          model.tableName,
          tableGeneratorColumnId,
          tableGeneratorOtherColumns,
        );

        const antSqlManager = new AntSqlManager();
        const factory = new QueryConfigFactory<NamedEntityTest>(this._dbConnection, model);
        const modelManager = antSqlManager.get(model).config({
          knex: this._dbConnection,
          redis: this._redisWrapper.redis,
        });
        const query = modelManager.query(factory.all());

        const player1 = { id: 1, name: 'name-1' };
        const player2 = { id: 2, name: 'name-1' };
        const player3 = { id: 3, name: 'name-2' };
        const player4 = { id: 4, name: 'name-3' };

        await modelManager.mInsert([player1, player2, player3, player4]);

        const playersQueryResult = await query.get({});
        const playersMQueryResult = await query.mGet([{}]);

        expect(playersQueryResult).toContain(player1);
        expect(playersQueryResult).toContain(player2);
        expect(playersQueryResult).toContain(player3);
        expect(playersQueryResult).toContain(player4);

        expect(playersMQueryResult).toContain(player1);
        expect(playersMQueryResult).toContain(player2);
        expect(playersMQueryResult).toContain(player3);
        expect(playersMQueryResult).toContain(player4);

        done();
      },
      MAX_SAFE_TIMEOUT,
    );
  }

  private _itMustBuildAValidQueryAllWithParameters(): void {
    const itsName = 'It must build a valid all query config with parameters';
    const prefix = this._declareName + '/' + itsName + '/';

    it(
      itsName,
      async (done) => {
        await this._beforeAllPromise;

        const model = namedModelGenerator({ prefix });
        await this._dbTestManager.createTable(
          this._dbConnection,
          model.tableName,
          tableGeneratorColumnId,
          tableGeneratorOtherColumns,
        );

        const antSqlManager = new AntSqlManager();
        const factory = new QueryConfigFactory<NamedEntityTest>(this._dbConnection, model);
        const modelManager = antSqlManager.get(model).config({
          knex: this._dbConnection,
          redis: this._redisWrapper.redis,
        });

        const keyGen = (): string => prefix + 'k-k-key';
        const reverseKey = prefix + 'reverse-key';

        const query = modelManager.query(
          factory.all({
            entityKeyGen: keyGen,
            queryKeyGen: keyGen,
            reverseHashKey: reverseKey,
          }),
        );

        const player1 = { id: 1, name: 'name-1' };
        const player2 = { id: 2, name: 'name-1' };
        const player3 = { id: 3, name: 'name-2' };
        const player4 = { id: 4, name: 'name-3' };

        await modelManager.mInsert([player1, player2, player3, player4]);

        await query.get({});

        const resultKeyExist = await this._redisWrapper.redis.exists(keyGen());
        const reverseKeyExists = await this._redisWrapper.redis.exists(reverseKey);
        const expectedResult = 1; // Exists (https://redis.io/commands/exists)

        expect(resultKeyExist).toBe(expectedResult);
        expect(reverseKeyExists).toBe(expectedResult);

        done();
      },
      MAX_SAFE_TIMEOUT,
    );
  }

  private _itMustBuildAValidQueryByFieldConfig(): void {
    const itsName = 'It must build a valid query by field config';
    const prefix = this._declareName + '/' + itsName + '/';
    it(
      itsName,
      async (done) => {
        await this._beforeAllPromise;

        const model = namedModelGenerator({ prefix });
        await this._dbTestManager.createTable(
          this._dbConnection,
          model.tableName,
          tableGeneratorColumnId,
          tableGeneratorOtherColumns,
        );

        const antSqlManager = new AntSqlManager();
        const factory = new QueryConfigFactory<NamedEntityTest>(this._dbConnection, model);
        const modelManager = antSqlManager.get(model).config({
          knex: this._dbConnection,
          redis: this._redisWrapper.redis,
        });
        const query = modelManager.query(factory.byField(model.columnByAlias('name')));

        const player1 = { id: 1, name: 'name-1' };
        const player2 = { id: 2, name: 'name-1' };
        const player3 = { id: 3, name: 'name-2' };
        const player4 = { id: 4, name: 'name-3' };

        await modelManager.mInsert([player1, player2, player3, player4]);

        const playersByName = await query.get({ name: 'name-1' });
        const playersByNames = await query.mGet([{ name: 'name-1' }, { name: 'name-2' }]);

        expect(playersByName).toContain(player1);
        expect(playersByName).toContain(player2);
        expect(playersByName).not.toContain(player3);
        expect(playersByName).not.toContain(player4);

        expect(playersByNames).toContain(player1);
        expect(playersByNames).toContain(player2);
        expect(playersByNames).toContain(player3);
        expect(playersByNames).not.toContain(player4);

        done();
      },
      MAX_SAFE_TIMEOUT,
    );
  }

  private _itMustBuildAValidQueryByFieldsConfig(): void {
    const itsName = 'It must build a valid query by fields config';
    const prefix = this._declareName + '/' + itsName + '/';
    it(
      itsName,
      async (done) => {
        await this._beforeAllPromise;

        const model = namedModelGenerator({ prefix });
        await this._dbTestManager.createTable(
          this._dbConnection,
          model.tableName,
          tableGeneratorColumnId,
          tableGeneratorOtherColumns,
        );

        const antSqlManager = new AntSqlManager();
        const factory = new QueryConfigFactory<NamedEntityTest>(this._dbConnection, model);
        const modelManager = antSqlManager.get(model).config({
          knex: this._dbConnection,
          redis: this._redisWrapper.redis,
        });
        const query = modelManager.query(factory.byFields([model.columnByAlias('name')]));

        const player1 = { id: 1, name: 'name-1' };
        const player2 = { id: 2, name: 'name-1' };
        const player3 = { id: 3, name: 'name-2' };
        const player4 = { id: 4, name: 'name-3' };

        await modelManager.mInsert([player1, player2, player3, player4]);

        const playersByName = await query.get({ name: 'name-1' });
        const playersByNames = await query.mGet([{ name: 'name-1' }, { name: 'name-2' }]);

        expect(playersByName).toContain(player1);
        expect(playersByName).toContain(player2);
        expect(playersByName).not.toContain(player3);
        expect(playersByName).not.toContain(player4);

        expect(playersByNames).toContain(player1);
        expect(playersByNames).toContain(player2);
        expect(playersByNames).toContain(player3);
        expect(playersByNames).not.toContain(player4);

        done();
      },
      MAX_SAFE_TIMEOUT,
    );
  }

  private _itMustBuildAValidQueryByNumericRangeConfig(): void {
    const itsName = 'It must build a valid query by numeric range config';
    const prefix = this._declareName + '/' + itsName + '/';
    it(
      itsName,
      async (done) => {
        await this._beforeAllPromise;

        const model = new AntSqlModel<AmountEntity>(
          'id',
          { prefix },
          [
            {
              entityAlias: 'id',
              sqlName: 'id',
              type: SqlType.Integer,
            },
            {
              entityAlias: 'amount',
              sqlName: 'amount',
              type: SqlType.Integer,
            },
          ],
          tableNameGenerator(prefix),
        );
        await this._dbTestManager.createTable(this._dbConnection, model.tableName, tableGeneratorColumnId, {
          amount: 'number',
        });

        const antSqlManager = new AntSqlManager();
        const factory = new QueryConfigFactory<AmountEntity>(this._dbConnection, model);

        const blockSize = 100;
        const minValueField = 'offSet';

        const queryConfig = factory.byNumericRange(model.columnByAlias('amount'), { blockSize, minValueField });

        const modelManager = antSqlManager.get(model).config({
          knex: this._dbConnection,
          redis: this._redisWrapper.redis,
        });

        const entity1: AmountEntity = { amount: -1, id: 1 };
        const entity2: AmountEntity = { amount: 0, id: 2 };
        const entity3: AmountEntity = { amount: blockSize - 1, id: 3 };
        const entity4: AmountEntity = { amount: blockSize, id: 4 };
        await modelManager.mInsert([entity1, entity2, entity3, entity4]);

        const query = modelManager.query(queryConfig);

        const queryParams: any = {};
        queryParams[minValueField] = 0;
        const queryResult = await query.get(queryParams);

        expect(queryResult).not.toContain(entity1);
        expect(queryResult).toContain(entity2);
        expect(queryResult).toContain(entity3);
        expect(queryResult).not.toContain(entity4);

        done();
      },
      MAX_SAFE_TIMEOUT,
    );
  }

  private _itMustBuildAValidQueryByNumericRangeConfigThatSyncsEntities(): void {
    const itsName = 'It must build a valid query by numeric range config that syncs entities';
    const prefix = this._declareName + '/' + itsName + '/';
    it(
      itsName,
      async (done) => {
        await this._beforeAllPromise;

        const model = new AntSqlModel<AmountEntity>(
          'id',
          { prefix },
          [
            {
              entityAlias: 'id',
              sqlName: 'id',
              type: SqlType.Integer,
            },
            {
              entityAlias: 'amount',
              sqlName: 'amount',
              type: SqlType.Integer,
            },
          ],
          tableNameGenerator(prefix),
        );
        await this._dbTestManager.createTable(this._dbConnection, model.tableName, tableGeneratorColumnId, {
          amount: 'number',
        });

        const antSqlManager = new AntSqlManager();
        const factory = new QueryConfigFactory<AmountEntity>(this._dbConnection, model);

        const blockSize = 100;
        const minValueField = 'offSet';

        const queryConfig = factory.byNumericRange(model.columnByAlias('amount'), { blockSize, minValueField });

        const modelManager = antSqlManager.get(model).config({
          knex: this._dbConnection,
          redis: this._redisWrapper.redis,
        });
        const query = modelManager.query(queryConfig);

        const entity1: AmountEntity = { amount: -1, id: 1 };
        const entity2: AmountEntity = { amount: 0, id: 2 };
        const entity3: AmountEntity = { amount: blockSize - 1, id: 3 };
        const entity4: AmountEntity = { amount: blockSize, id: 4 };
        await modelManager.mInsert([entity1, entity2, entity3, entity4]);

        const queryParams0: any = {};
        queryParams0[minValueField] = 0;
        await query.get(queryParams0);

        entity3.amount = -(blockSize + 1);
        entity4.amount = -blockSize;

        await modelManager.mUpdate([entity3, entity4]);

        const queryParamsMinus1: any = {};
        queryParamsMinus1[minValueField] = -blockSize;

        const [queryResultMinus1, queryResult0] = await Promise.all([
          query.get(queryParamsMinus1),
          query.get(queryParams0),
        ]);

        expect(queryResultMinus1).toContain(entity1);
        expect(queryResultMinus1).not.toContain(entity2);
        expect(queryResultMinus1).not.toContain(entity3);
        expect(queryResultMinus1).toContain(entity4);
        expect(queryResult0).not.toContain(entity1);
        expect(queryResult0).toContain(entity2);
        expect(queryResult0).not.toContain(entity3);
        expect(queryResult0).not.toContain(entity4);

        done();
      },
      MAX_SAFE_TIMEOUT,
    );
  }

  private _itMustBuildAValidQueryByUniqueFieldConfig(): void {
    const itsName = 'It must build a valid query by unique field config';
    const prefix = this._declareName + '/' + itsName + '/';
    it(
      itsName,
      async (done) => {
        await this._beforeAllPromise;

        const model = namedModelGenerator({ prefix });
        await this._dbTestManager.createTable(
          this._dbConnection,
          model.tableName,
          tableGeneratorColumnId,
          tableGeneratorOtherColumns,
        );

        const antSqlManager = new AntSqlManager();
        const factory = new QueryConfigFactory<NamedEntityTest>(this._dbConnection, model);
        const modelManager = antSqlManager.get<NamedEntityTest>(model).config({
          knex: this._dbConnection,
          redis: this._redisWrapper.redis,
        });

        const player1 = { id: 1, name: 'name-1' };
        const player2 = { id: 2, name: 'name-2' };
        const player3 = { id: 3, name: 'name-3' };
        const player4 = { id: 4, name: 'name-4' };
        await modelManager.mInsert([player1, player2, player3, player4]);

        const query = modelManager.query(factory.byUniqueField(model.columnByAlias('name')));

        const playerByName = await query.get({ name: player1.name });
        const playersByNames = await query.mGet([{ name: player1.name }, { name: player2.name }]);

        expect(playerByName).toEqual(player1);

        expect(playersByNames).toContain(player1);
        expect(playersByNames).toContain(player2);
        expect(playersByNames).not.toContain(player3);
        expect(playersByNames).not.toContain(player4);

        done();
      },
      MAX_SAFE_TIMEOUT,
    );
  }

  private _itMustBuildAValidQueryByUniqueFieldsConfig(): void {
    const itsName = 'It must build a valid query by unique fields config';
    const prefix = this._declareName + '/' + itsName + '/';
    it(
      itsName,
      async (done) => {
        await this._beforeAllPromise;

        const model = namedModelGenerator({ prefix });
        await this._dbTestManager.createTable(
          this._dbConnection,
          model.tableName,
          tableGeneratorColumnId,
          tableGeneratorOtherColumns,
        );

        const antSqlManager = new AntSqlManager();
        const factory = new QueryConfigFactory<NamedEntityTest>(this._dbConnection, model);
        const modelManager = antSqlManager.get<NamedEntityTest>(model).config({
          knex: this._dbConnection,
          redis: this._redisWrapper.redis,
        });

        const player1 = { id: 1, name: 'name-1' };
        const player2 = { id: 2, name: 'name-2' };
        const player3 = { id: 3, name: 'name-3' };
        const player4 = { id: 4, name: 'name-4' };
        await modelManager.mInsert([player1, player2, player3, player4]);

        const query = modelManager.query(factory.byUniqueFields([model.columnByAlias('name')]));

        const playerByName = await query.get({ name: player1.name });
        const playersByNames = await query.mGet([{ name: player1.name }, { name: player2.name }]);

        expect(playerByName).toEqual(player1);

        expect(playersByNames).toContain(player1);
        expect(playersByNames).toContain(player2);
        expect(playersByNames).not.toContain(player3);
        expect(playersByNames).not.toContain(player4);

        done();
      },
      MAX_SAFE_TIMEOUT,
    );
  }

  private _itMustMQueryWithRepeatedQueries(): void {
    const itsName = 'It must perform an mquery with repeated queries';
    const prefix = this._declareName + '/' + itsName + '/';
    it(
      itsName,
      async (done) => {
        await this._beforeAllPromise;

        const model = namedModelGenerator({ prefix });
        await this._dbTestManager.createTable(
          this._dbConnection,
          model.tableName,
          tableGeneratorColumnId,
          tableGeneratorOtherColumns,
        );

        const antSqlManager = new AntSqlManager();
        const factory = new QueryConfigFactory<NamedEntityTest>(this._dbConnection, model);
        const modelManager = antSqlManager.get<NamedEntityTest>(model).config({
          knex: this._dbConnection,
          redis: this._redisWrapper.redis,
        });
        const query = modelManager.query(factory.byField(model.columnByAlias('name')));

        const player1 = { id: 1, name: 'name-1' };
        const player2 = { id: 2, name: 'name-1' };
        const player3 = { id: 3, name: 'name-2' };
        const player4 = { id: 4, name: 'name-3' };

        await modelManager.mInsert([player1, player2, player3, player4]);

        const playersByNames = await query.mGet([{ name: 'name-1' }, { name: 'name-1' }]);

        expect(playersByNames).toContain(player1);
        expect(playersByNames).toContain(player2);
        expect(playersByNames).not.toContain(player3);
        expect(playersByNames).not.toContain(player4);

        done();
      },
      MAX_SAFE_TIMEOUT,
    );
  }
}
